Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/IMUdrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\n\r\n\r\nimport com.qualcomm.hardware.rev.RevHubOrientationOnRobot;\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorController;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.IMU;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\r\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.YawPitchRollAngles;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\r\n\r\nimport java.nio.DoubleBuffer;\r\nimport java.util.List;\r\n\r\n@Autonomous(name = \"(IMUdrive)\", group = \"Sensor\")\r\npublic class IMUdrive extends LinearOpMode{\r\n\r\n    IMU imu;\r\n    private DcMotor frontLeft;\r\n    private DcMotor backLeft;\r\n    private DcMotor frontRight;\r\n    private DcMotor backRight;\r\n    private DcMotor linear;\r\n    private Servo claw;\r\n    boolean loopDone = false;\r\n\r\n    private static final String TFOD_MODEL_FILE  = \"/sdcard/FIRST/tflitemodels/ConeDetect.tflite\";\r\n\r\n\r\n    private static final String[] LABELS = {\r\n            \"1\",\r\n            \"2\",\r\n            \"3\"\r\n    };\r\n    private static final String VUFORIA_KEY =\r\n            \"ASlEG4X/////AAABmY1ivleqDEAOlO+c8WLrjuQ0XPykAjsJdqSDj8SE3Rdi0UitfIUC9nDsxtCi1QiucOpnxiguhOHRIjMXSE3fNiAq8nOVZKz5aEh6xd45UyvSqt4DifeXZqgpAN7n7yzaphd9eC0vmhlLUUt6RX4XtU9IUuumCXEgwqAOfKvJtx9h8LlgNhLgrkifTRm0xAcqwD3N2u7GRmqtpY4WF2D9Y6V3kWLWOLC67x2QGQZuKVdWNq4G+0Ie/JxWqE9RbOI8GOlocLEHlPV1PJNt7Mx7I4lrhf95UJ3A1uNpYeJDjB3kGYkoppWKSgDc6AZCh5KYoXhQRiVARuchnHssrsj3UK6b5cSFTBjN+VhZhj/+ixBU\";\r\n    private VuforiaLocalizer vuforia;\r\n\r\n    private TFObjectDetector tfod;\r\n\r\n    private void initVuforia() {\r\n        /*\r\n         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.\r\n         */\r\n        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\r\n\r\n        parameters.vuforiaLicenseKey = VUFORIA_KEY;\r\n        parameters.cameraName = hardwareMap.get(WebcamName.class, \"webcam\");\r\n\r\n        //  Instantiate the Vuforia engine\r\n        vuforia = ClassFactory.getInstance().createVuforia(parameters);\r\n    }\r\n    private void initTfod() {\r\n        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\r\n                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\r\n        tfodParameters.minResultConfidence = 0.600f;\r\n        tfodParameters.isModelTensorFlow2 = true;\r\n        tfodParameters.inputSize = 300;\r\n        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\r\n\r\n        // Use loadModelFromAsset() if the TF Model is built in as an asset by Android Studio\r\n        // Use loadModelFromFile() if you have downloaded a custom team model to the Robot Controller's FLASH.\r\n        //tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABELS);\r\n\r\n\r\n        tfod.loadModelFromFile(TFOD_MODEL_FILE, LABELS);\r\n    }\r\n\r\n    public void setPower(boolean half, double speed, double speed2){\r\n        if (half) {\r\n            frontRight.setPower(speed);\r\n            backRight.setPower(speed);\r\n            frontLeft.setPower(speed2);\r\n            backLeft.setPower(speed2);\r\n        }else {\r\n            frontLeft.setPower(speed);\r\n            frontRight.setPower(speed);\r\n            backLeft.setPower(speed);\r\n            backRight.setPower(speed);\r\n        }\r\n    }\r\n\r\n    public void strafe(double rotations, double speed,boolean left){\r\n        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        double data = 538*rotations;\r\n        int value = (int)data;\r\n        telemetry.addData(\"GoalTicks\", value);\r\n        if(left){\r\n            frontRight.setTargetPosition(value);\r\n            backLeft.setTargetPosition(value);\r\n            frontLeft.setTargetPosition(-value);\r\n            backRight.setTargetPosition(-value);\r\n        } else {\r\n            frontRight.setTargetPosition(-value);\r\n            backLeft.setTargetPosition(-value);\r\n            frontLeft.setTargetPosition(value);\r\n            backRight.setTargetPosition(value);\r\n        }\r\n        backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        if(left){\r\n            frontRight.setPower(value);\r\n            backLeft.setPower(value);\r\n            frontLeft.setPower(-value);\r\n            backRight.setPower(-value);\r\n        } else {\r\n            frontRight.setPower(-value);\r\n            backLeft.setPower(-value);\r\n            frontLeft.setPower(value);\r\n            backRight.setPower(value);\r\n        }\r\n        while(backLeft.isBusy() && frontLeft.isBusy()&&frontRight.isBusy()&&backRight.isBusy()){\r\n\r\n        }\r\n        setPower(false, 0,0);\r\n        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n    }\r\n\r\n    public void move(double rotations, double speed, boolean back){\r\n        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        double data = 538*rotations;\r\n                int value = (int)data;\r\n                telemetry.addData(\"GoalTicks\", value);\r\n        backLeft.setTargetPosition(value);\r\n        frontLeft.setTargetPosition(value);\r\n        frontRight.setTargetPosition(value);\r\n        backRight.setTargetPosition(value);\r\n        backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        if (back) {\r\n            setPower(false, -speed, 0);\r\n        } else {\r\n            setPower(false, speed, 0);\r\n        }\r\n        while(backLeft.isBusy() && frontLeft.isBusy()&&frontRight.isBusy()&&backRight.isBusy()){\r\n\r\n        }\r\n        setPower(false, 0,0);\r\n        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n    }\r\n\r\n    public void left(int angle){\r\n        imu.resetYaw();\r\n        frontLeft.setPower(-0.5);\r\n        backLeft.setPower(-0.5);\r\n        frontRight.setPower(0.5);\r\n        backRight.setPower(0.5);\r\n        while (!loopDone) {\r\n            YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();\r\n            if (orientation.getYaw(AngleUnit.DEGREES)>=angle){\r\n                frontLeft.setPower(0);\r\n                backLeft.setPower(0);\r\n                frontRight.setPower(0);\r\n                backRight.setPower(0);\r\n                loopDone=true;\r\n            }\r\n\r\n            telemetry.addData(\"Yaw (Z)\", \"%.2f Deg. (Heading)\", orientation.getYaw(AngleUnit.DEGREES));\r\n            telemetry.update();\r\n        }\r\n        loopDone=false;\r\n        frontLeft.setPower(0.1);\r\n        backLeft.setPower(0.1);\r\n        frontRight.setPower(-0.1);\r\n        backRight.setPower(-0.1);\r\n        while (!loopDone){\r\n            YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();\r\n            if (orientation.getYaw(AngleUnit.DEGREES)<=angle){\r\n                frontLeft.setPower(0);\r\n                backLeft.setPower(0);\r\n                frontRight.setPower(0);\r\n                backRight.setPower(0);\r\n                loopDone=true;\r\n            }\r\n\r\n            telemetry.addData(\"Yaw (Z)\", \"%.2f Deg. (Heading)\", orientation.getYaw(AngleUnit.DEGREES));\r\n            telemetry.update();\r\n        }\r\n        loopDone=false;\r\n    }\r\n\r\n    public void right(int angle){\r\n        imu.resetYaw();\r\n        frontLeft.setPower(0.5);\r\n        backLeft.setPower(0.5);\r\n        frontRight.setPower(-0.5);\r\n        backRight.setPower(-0.5);\r\n        while (!loopDone) {\r\n            YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();\r\n            if (orientation.getYaw(AngleUnit.DEGREES)<=-angle){\r\n                frontLeft.setPower(0);\r\n                backLeft.setPower(0);\r\n                frontRight.setPower(0);\r\n                backRight.setPower(0);\r\n                loopDone=true;\r\n            }\r\n\r\n            telemetry.addData(\"Yaw (Z)\", \"%.2f Deg. (Heading)\", orientation.getYaw(AngleUnit.DEGREES));\r\n            telemetry.update();\r\n        }\r\n        loopDone=false;\r\n        frontLeft.setPower(-0.1);\r\n        backLeft.setPower(-0.1);\r\n        frontRight.setPower(0.1);\r\n        backRight.setPower(0.1);\r\n        while (!loopDone){\r\n            YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();\r\n            if (orientation.getYaw(AngleUnit.DEGREES)>=-angle){\r\n                frontLeft.setPower(0);\r\n                backLeft.setPower(0);\r\n                frontRight.setPower(0);\r\n                backRight.setPower(0);\r\n                loopDone=true;\r\n            }\r\n\r\n            telemetry.addData(\"Yaw (Z)\", \"%.2f Deg. (Heading)\", orientation.getYaw(AngleUnit.DEGREES));\r\n            telemetry.update();\r\n        }\r\n        loopDone=false;\r\n    }\r\n    public void linearMove(double rotations, double speed, boolean down) {\r\n        linear.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        double data = 538*rotations;\r\n        int value = (int)data;\r\n        telemetry.addData(\"GoalTicks\", value);\r\n        linear.setTargetPosition(value);\r\n        linear.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        if (down){\r\n            linear.setPower(-speed);\r\n        } else {\r\n            linear.setPower(speed);\r\n        }\r\n        while(backLeft.isBusy() && frontLeft.isBusy()&&frontRight.isBusy()&&backRight.isBusy()){\r\n\r\n        }\r\n        linear.setPower(0);\r\n        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n    }\r\n\r\n\r\n\r\n    @Override public void runOpMode() throws InterruptedException {\r\n\r\n        imu = hardwareMap.get(IMU.class, \"imu\");\r\n        linear = hardwareMap.get(DcMotor.class, \"linear\");\r\n        frontLeft = hardwareMap.get(DcMotor.class, \"frontLeft\");\r\n        backLeft = hardwareMap.get(DcMotor.class, \"backLeft\");\r\n        frontRight = hardwareMap.get(DcMotor.class, \"frontRight\");\r\n        backRight = hardwareMap.get(DcMotor.class, \"backRight\");\r\n        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        frontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        backLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        frontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        backRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        RevHubOrientationOnRobot.LogoFacingDirection logoDirection = RevHubOrientationOnRobot.LogoFacingDirection.UP;\r\n        RevHubOrientationOnRobot.UsbFacingDirection  usbDirection  = RevHubOrientationOnRobot.UsbFacingDirection.BACKWARD;\r\n        RevHubOrientationOnRobot orientationOnRobot = new RevHubOrientationOnRobot(logoDirection, usbDirection);\r\n        imu.initialize(new IMU.Parameters(orientationOnRobot));\r\n        telemetry.addData(\"InOpMode\", \"\");\r\n        initVuforia();\r\n        telemetry.addData(\"loadedvuforia\", \"\");\r\n        initTfod();\r\n        telemetry.addData(\"RanTfod\", \"\");\r\n        /**\r\n         * Activate TensorFlow Object Detection before we wait for the start command.\r\n         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\r\n         **/\r\n        if (tfod != null) {\r\n            telemetry.addData(\"tfod not null\", \"\");\r\n            tfod.activate();\r\n            telemetry.addData(\"We activated\", \"We activated\");\r\n            // The TensorFlow software will scale the input images from the camera to a lower resolution.\r\n            // This can result in lower detection accuracy at longer distances (> 55cm or 22\").\r\n            // If your target is at distance greater than 50 cm (20\") you can increase the magnification value\r\n            // to artificially zoom in to the center of image.  For best results, the \"aspectRatio\" argument\r\n            // should be set to the value of the images used to create the TensorFlow Object Detection model\r\n            // (typically 16/9).\r\n            tfod.setZoom(1.0, 16.0/9.0);\r\n            telemetry.addData(\"setzoom\", \"\");\r\n        }\r\n        else {\r\n            telemetry.addData(\"tfod is null\", \"\");\r\n        }\r\n\r\n        /** Wait for the game to begin */\r\n        telemetry.addData(\">\", \"Press Play to start op mode\");\r\n        telemetry.update();\r\n\r\n        boolean Scanned=false;\r\n        waitForStart();\r\n        telemetry.addData(\"started\", \"\");\r\n        int i = 0;\r\n        int l = 0;\r\n        if (opModeIsActive()) {\r\n            while (opModeIsActive()&&!Scanned) {\r\n\r\n                telemetry.update();\r\n                if (tfod != null) {\r\n                    // getUpdatedRecognitions() will return null if no new information is available since\r\n                    // the last time that call was made.\r\n                    List<Recognition> updatedRecognitions = tfod.getRecognitions();\r\n                    //if (updatedRecognitions != null) {\r\n                    telemetry.addData(\"# Objects Detected\", updatedRecognitions.size());\r\n\r\n                    // step through the list of recognitions and display image position/size information for each one\r\n                    // Note: \"Image number\" refers to the randomized image orientation/number\r\n                    for (Recognition recognition : updatedRecognitions) {\r\n                        l++;\r\n\r\n                        double col = (recognition.getLeft() + recognition.getRight()) / 2 ;\r\n                        double row = (recognition.getTop()  + recognition.getBottom()) / 2 ;\r\n                        double width  = Math.abs(recognition.getRight() - recognition.getLeft()) ;\r\n                        double height = Math.abs(recognition.getTop()  - recognition.getBottom()) ;\r\n                        telemetry.addData(\"\", \"\");\r\n                        telemetry.addData(\"\",\" \");\r\n                        telemetry.addData(\"Image\", \"%s (%.0f %% Conf.)\", recognition.getLabel(), recognition.getConfidence() * 100 );\r\n                        telemetry.addData(\"- Position (Row/Col)\",\"%.0f / %.0f\", row, col);\r\n                        telemetry.addData(\"- Size (Width/Height)\",\"%.0f / %.0f\", width, height);\r\n                    }\r\n                    telemetry.update();\r\n                    // }\r\n                }\r\n                else {\r\n                    telemetry.addData(\"tfod is null again\", \"\");\r\n                    Scanned=true;\r\n                }\r\n                right(90);\r\n            }\r\n        }\r\n\r\n\r\n\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/IMUdrive.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/IMUdrive.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/IMUdrive.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/IMUdrive.java	
@@ -116,15 +116,15 @@
         frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
         backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
         if(left){
-            frontRight.setPower(value);
-            backLeft.setPower(value);
-            frontLeft.setPower(-value);
-            backRight.setPower(-value);
+            frontRight.setPower(speed);
+            backLeft.setPower(speed);
+            frontLeft.setPower(-speed);
+            backRight.setPower(-speed);
         } else {
-            frontRight.setPower(-value);
-            backLeft.setPower(-value);
-            frontLeft.setPower(value);
-            backRight.setPower(value);
+            frontRight.setPower(-speed);
+            backLeft.setPower(-speed);
+            frontLeft.setPower(speed);
+            backRight.setPower(speed);
         }
         while(backLeft.isBusy() && frontLeft.isBusy()&&frontRight.isBusy()&&backRight.isBusy()){
 
@@ -332,7 +332,7 @@
         int i = 0;
         int l = 0;
         if (opModeIsActive()) {
-            while (opModeIsActive()&&!Scanned) {
+            while (!Scanned) {
 
                 telemetry.update();
                 if (tfod != null) {
@@ -341,7 +341,7 @@
                     List<Recognition> updatedRecognitions = tfod.getRecognitions();
                     //if (updatedRecognitions != null) {
                     telemetry.addData("# Objects Detected", updatedRecognitions.size());
-
+                    Scanned=true;
                     // step through the list of recognitions and display image position/size information for each one
                     // Note: "Image number" refers to the randomized image orientation/number
                     for (Recognition recognition : updatedRecognitions) {
@@ -356,16 +356,19 @@
                         telemetry.addData("Image", "%s (%.0f %% Conf.)", recognition.getLabel(), recognition.getConfidence() * 100 );
                         telemetry.addData("- Position (Row/Col)","%.0f / %.0f", row, col);
                         telemetry.addData("- Size (Width/Height)","%.0f / %.0f", width, height);
+                        Scanned=true;
                     }
                     telemetry.update();
                     // }
                 }
                 else {
                     telemetry.addData("tfod is null again", "");
-                    Scanned=true;
+                linearMove(0.25, 0.25, false);
                 }
-                right(90);
+
             }
+        //strafe(3.3,0.25,true);
+
         }
 
 
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Top-level build file for ftc_app project.\r\n *\r\n * It is extraordinarily rare that you will ever need to edit this file.\r\n */\r\n\r\nbuildscript {\r\n    repositories {\r\n        mavenCentral()\r\n        google()\r\n    }\r\n    dependencies {\r\n        classpath 'com.android.tools.build:gradle:7.2.0'\r\n    }\r\n}\r\n\r\n// This is now required because aapt2 has to be downloaded from the\r\n// google() repository beginning with version 3.2 of the Android Gradle Plugin\r\nallprojects {\r\n    repositories {\r\n        mavenCentral()\r\n        google()\r\n    }\r\n}\r\n\r\nrepositories {\r\n    mavenCentral()\r\n\r\n    flatDir {\r\n        dirs '../libs'\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle b/build.gradle
--- a/build.gradle	
+++ b/build.gradle	
@@ -10,7 +10,7 @@
         google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:7.2.0'
+        classpath 'com.android.tools.build:gradle:7.3.1'
     }
 }
 
